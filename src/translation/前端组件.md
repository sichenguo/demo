### 前言

我在最近的工作中开始使用 Vue 进行开发，但是我在上一家公司积累了三年以上 React 开发经验。虽然在两种不同的前端框架之间进行切换确实需要学习很多，但是二者之间在很多基础概念、设计思路上是相通的。其中之一就是组件设计，包括组件层次结构设计以及组件各自的职责划分。

组件是大多数现代前端框架的基本概念之一，在 React 和 Vue 以及  Ember 和 Mithril 等框架中均有所体现。组件通常是由一串标记语言组成的集合，通常还包含一些逻辑和样式。它们被创建的目的就是作为可复用的模块去构建我们的应用程序。

类似于传统 OOP 语言中 class 的设计，在设计组件的时候需要考虑到很多方面，以便它们可以很好的复用，组合，分离和低耦合，但是功能可以比较稳定的实现，即使是在超出实际测试用例范围的情况下。这样的设计说起来容易做起来却很难，因为现实中我们往往没有足够的时间按照最优的方式去做。

### 方法

在本文中，我想介绍一些组件相关的设计概念，在进行前端开发时应该考虑这些概念。我认为最好的方法是给每个概念一个简洁精炼的名字，然后逐一解释每个概念是什么以及为什么重要，对于比较抽象概念的会举一些例子来帮助理解。

以下这个列表并不是不全面也不完整，但我注意到的只有8件事情值得一提，对于那些已经可以编写基本组件但想要提高他们的技术设计技能的人来说。所以这是列表：
以下列举的这个列表仅仅是是我注意到的 8 个方面，当然组件设计还有其他一些方面。在此我只是列举出来我认为值得一提的。

对于已经掌握基本的组件设计并且想要提高自身的组件设计能力的开发者，我认为以下 8 项是我认为值得去注意的，当然这并不是组件设计的全部。

1. 层次结构和 UML 类图
2. 扁平化、面向数据的 state/props
3. State change purity
4. 低耦合
5. 抽离辅助代码
6. View distillation
7. 及时模块化
8. Centralised state considerations

请注意，代码示例可能有一些小问题或有点人为设计。但是它们并不复杂，只是通过举例帮助更好的额理解概念。

### 层次结构和类图

应用内的组件共同形成树结构， 而在设计过程中将组件树可视化展示可以帮助你全面了解应用程序的布局。一个比较好的展示这些的办法就是组件图。

UML中有一个在 OOP 类设计中经常使用的类型，称为 UML 类图。类图中显示了类属性、方法、访问修饰符、类与其他类的关系等。虽然 OOP 类设计和前端组件设计差异很大，但是通过图解辅助设计的方法值得参考。对于前端组件，该图表可以显示：

- State
- Props
- Methods
- 与其他组件的关系（ Relationship to other components ）

因此，让我们看一下下面这个基础表组件的组件层次图，该组件的渲染对象是一个数组。该组件的功能包括显示总行数、标题行和一些数据行，以及在单击其单元格标题格时对该列进行排序。在它的 props 中，它将传递列列表（具有属性名称和该属性的人类可读版本），然后传递数据数组。我们可以添加一个可选的'on row click'功能来进行测试。

![img](https://cdn-images-1.medium.com/max/1600/0*BpUkUiLupqoBO3ux)

虽然这样的事情可能看起来有点多，并且绝对可以完全涉及大型应用程序，但它具有许多优点。一个重要的问题是它会强迫您在开始编写任何代码之前考虑具体细节，例如每个组件需要什么类型的数据，需要实现哪些方法，所需的状态属性等等。

一旦你对如何构建一个组件（或一组组件）有了一般的想法，就很容易认为当你真正开始编码时，它会像你期望的那样整齐地充实自己，但几乎总会有东西你不适应。您不希望重做项目的某些部分或因此使用混乱的工作。这些图的其他优点包括：

1. 一个易于理解的组件组成和关联视图
2. 易于理解的应用程序UI层次结构概述
3. 层次结构数据及其流动方式的视图
4. 组件功能职责的快照
5. 使用图表软件创建起来相对容易

我应该提一下，上图不是基于某些官方标准，比如UML类图，它是我基本上编写的。例如，我使用Typescript语法作为props和方法的参数和返回值的数据类型的基础。我还没有找到前端组件的官方标准，可能是由于前端Javascript开发的相对较新且快节奏的生态系统，但如果有人知道主流标准，请在回复中告诉我！

### 扁平的，面向数据的状态/道具

状态和道具经常被观看和更新。如果您有嵌套数据，那么您的性能可能会受到影响，例如通过浅层相等检查不必要的重新呈现。在涉及不可变性的库中，比如React，你必须创建状态的副本而不是像在Vue中那样直接更改它们，并且使用嵌套数据这样做可能会创建笨拙，丑陋的代码。

![img](https://cdn-images-1.medium.com/max/1600/0*mZkPIHnDUAJqnggm)

即使使用传播运营商，这也不是很好。扁平道具还可以很好地清除组件正在使用的数据值。如果你传入一个对象然后你不知道它的属性是什么，所以找出组件的道具*实际*是什么是额外的工作。但如果你把对象弄平，那么看你正在使用它的速度要快得多。

![img](https://cdn-images-1.medium.com/max/1600/0*oWFoKOVdtDEiOt5t)

state / props还应该只包含呈现标记所需的数据。您不应将整个组件存储在状态/道具中并直接从那里渲染。

（此外，对于数据繁重的应用程序，数据规范化可以带来巨大的好处，除了扁平化之外，您可能还需要考虑这样做）。

### 国家改变纯度

对状态的更改通常应该响应某种事件，例如用户单击按钮或返回API响应。它们不应该响应其他状态更改，因为此链接可能会创建难以理解和维护的组件行为。国家变化应该没有副作用。

如果你滥用`watch`而不是将这个逻辑烘焙到任何事件处理程序处理状态变化的第一个位置，那么可以在Vue中看到这个问题。我们来看一个基本的Vue示例。我正在研究一个从API获取一些数据并将其呈现给表的组件。排序，过滤等所有内容都是后端完成的，因此我们有一系列观察者在前端观看所有搜索参数，并在更改时触发API调用。一个这样的值是“区域”，这是一个过滤器。当更改时，我们想要使用新的过滤器值重新获取数据。所以为它设置了一个简单的观察者：



![img](https://cdn-images-1.medium.com/max/1600/0*gmnqOd2JMQwEn0sm)

你会发现一些奇怪的东西。如果他们超出了结果的第一页，我们重置页码并返回？返回？！这似乎不对。如果它们不在第一页上，我们应该重置分页并触发API调用，对吧？为什么我们只在第1页上重新获取数据？事实证明有一个原因，这是完整的手表属性：



![img](https://cdn-images-1.medium.com/max/1600/0*93mIcG6EdFJUcAvb)

当分页改变时，它也通过分页观察器获取数据。因此，如果我们改变了分页，我们就不需要触发API搜索，因为分页观察者已经这样做了。

让我们考虑一下流程：如果它们超出了第1页并且更改了区域，它将触发状态更改，这将触发状态更改，这将重新获取数据。这不是可预测的行为，并产生不直观的代码。

解决方案是分页的事件处理程序（不是观察者，用户更改页面的实际处理程序）应该更改页面值**并**触发API调用。这也将消除对观察者的需求。通过这样的设置，直接从其他地方改变分页状态也不会导致重新获取数据的副作用。

虽然这个例子**非常**简单，但不难看出如何将更复杂的状态更改链接在一起会产生非常难以理解的代码，这些代码不可扩展并且是调试的噩梦。

### 松耦合

组件的核心思想是它们是可重用的，并且为此它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的道具的多少，以及它呈现的子级（以及导入，如第三方模块或自定义脚本）。

紧密耦合的组件往往是更多的重用工作，当它们不是原始父组件的子项时，没有正常运行，有一个孩子或一系列只在其原始上下文中有意义的子项，并导致代码重复，因为它们被过度装配他们原来的用例。

在设计组件时，您应该尝试考虑一般用例，而不是最初要满足的特定用例。虽然某些组件显然只是出于特定目的，但没关系，如果在设计它们时以广泛的视角处理它们，那么很多组件将具有更广泛的适用性。

让我们看一个简单的React用例，你想在其中列出一个链接列表，用于浏览你的站点，并显示一个徽标。在这种情况下，我们将考虑从最初设计的上下文中解除绑定组件。这是最初的版本：

![img](https://cdn-images-1.medium.com/max/1600/0*YdWfhl9HILY99Di0)

虽然这可能会满足最初的预期用例，但它在任何情况下都不可重复使用，除了它的初始上下文。如果您想要拥有不同的链接，取决于他们是否是管理员，该怎么办？你必须复制粘贴它并更改路线。而且，假设您知道自己想要实现用户可以自定义链接的功能。你无法实际硬编码，因为可能存在各种组合。让我们制作一个更可重用的组件：

![img](https://cdn-images-1.medium.com/max/1600/0*SRwtEhiEfcFEneFa)

在这里我们可以看到，虽然它确实有原始链接和标识为默认值，我们可以在道具覆盖它们通过。因此，假设我们要为管理员使用创建特殊用例：

![img](https://cdn-images-1.medium.com/max/1600/0*bgK5B8oRXhMQJQWG)

无需新组件！如果需要，我们也可以动态构建链接数组，这解决了用户拥有自定义链接列表的用例。此外，虽然在这个具体的例子中没有解决，但我们仍然可以注意到这个组件没有绑定到任何特定的父或子。它可以在任何需要的地方呈现。现在，这个组件比原始环境更可重用。

假设它不提供高度特定的一次性用例，设计组件的最终目标是它与父组件松散耦合，呈现泛型和逻辑子元素，而不受其上下文的约束。起源。

### 辅助代码分离

这个可能不那么学术，但我仍然认为这很重要。与您的代码库进行物理交互是软件工程的一部分，有时一些基本的组织原则可以使事情变得更加顺畅。在数周内每天工作8小时的代码库时，小的改动可以产生很大的不同。一个这样的组织原则是将辅助代码分离到自己的文件中的想法，这样您在处理组件时就不必处理它。此类代码包括但不限于以下内容：

- 配置代码
- 虚拟数据
- 大量非技术文档

在尝试处理组件的核心代码时，不仅需要滚动这些内容而且会加剧偏见，这不仅麻烦而烦人。在处理组件时，您希望它们尽可能通用且可重用。查看与组件当前上下文相关的特定信息可能会使组件的使用难以超出其原始用例。

### 查看蒸馏

虽然它可能具有挑战性，但开发组件的一个好方法是使它们包含渲染它们所需的最小Javascript。一些无关紧要的东西，比如数据提取，数据整理或事件处理逻辑，理想情况下应该是通用的，并移入外部脚本或升级为共同的祖先。

这将组件分解为它的“视图”部分，即您看到的内容（标记和样式）。其中的Javascript仅用于帮助渲染视图，*可能*还有一些特定于该组件的额外逻辑（即在其他地方使用）。除此之外的任何事情，例如API调用，值的非特定格式化（例如货币或时间）或跨组件重用的数据，可以移动到提升的外部脚本。让我们看一下Vue中的一个简单示例，使用嵌套列表组件。我们可以先查看有问题的版本。

这是第一级：

![img](https://cdn-images-1.medium.com/max/1600/0*P5gJwro7sZUhBr_7)

这是嵌套列表组件：

![img](https://cdn-images-1.medium.com/max/1600/0*9nsuVNekUXJ24FEN)

在这里我们可以看到此列表的两个级别都具有外部依赖关系，顶级导入脚本中的函数和来自JSON文件的数据，嵌套组件连接到Vuex存储并使用axios发布。它们还具有仅适用于其当前使用的嵌入式功能（顶级数据处理和嵌套列表的onClick功能）。

虽然这里采用了一些很好的通用设计技术，例如将通用的munging函数移动到外部脚本而不是嵌入硬编码数据，但这仍然不是非常可重用的。如果我们想要完全相同类型的列表，但是从API获取其数据会怎么样？或者在单击嵌套项时有不同的行为？我们根本无法将其复制/粘贴到一些新组件中并更改这些功能。

让我们看看我们是否可以通过提升数据并将事件处理作为props传递来解决这个问题，这样组件就可以简单地呈现数据而不会封装任何其他逻辑。

这是列表的新顶级：

![img](https://cdn-images-1.medium.com/max/1600/0*_OM8O-ONfOtk8mqP)

而新的第二级：

![img](https://cdn-images-1.medium.com/max/1600/0*Kx5vgTwEMt8FmBdz)

使用这个新列表，我们获得了我们想要的数据，并定义了嵌套的onClick处理程序，以便在父级中执行任何我们想要的操作，然后将它们作为props传递给顶级组件。这样，我们不需要在为新用例利用它们时复制任何组件，我们可以将导入和逻辑留给单个根组件。

有关此主题的简短文章可以在[这里](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)找到。它由Redux的共同创建者Dan Abramov编写，具体与React有关。但是，它适用于通用组件设计。

### 及时模块化

在尝试更加主动地将代码分解为松散耦合的，可重用的块是一件好事时，它当然有可能过火。并非每一点标记都需要成为它自己的组件，并不是每一点逻辑都需要被拉出到外部脚本。

在决定是否将代码分开时，无论是Javascript逻辑还是新组件，都需要考虑以下几点。同样，这个列表并不完整，只是为了让您了解需要考虑的各种事项。（记住，仅仅因为它不满足一个条件并不意味着它不会满足其他条件，所以在做出决定之前要考虑所有条件）：

1. **是否有足够的标记/逻辑来保证它？**如果它只是几行代码，那么最终可能会创建更多的代码来分隔它，而不仅仅是将代码放入其中。
2. **代码重复（或可能重复）？**如果某些东西只使用一次，并且服务于一个不太可能在其他地方使用的特定用例，那么将它嵌入其中可能会更好。如果需要，您可以随时将其分开（但不要以此为借口永远不要这样做）。
3. **它会减少你的样板吗？**例如，假设您想要一个用于样式的div树和一些静态内容/功能，其中一些可变内容嵌套在中心。通过创建可重用的包装器（与React的HOC或Vue的插槽一样），您可以在创建这些组件的多个实例时减少样板，因为您不需要复制/粘贴所有静态包装代码。
4. **你的表现难受吗？**更改状态/道具会导致重新渲染，当发生这种情况时，您只需要对相关元素进行衍射和重新渲染。在较大的，无差别的组件中，您可能会发现状态更改会导致在不需要它的许多地方重新呈现，并且您的性能可能会开始受损。
5. **您是否在测试代码的所有部分时遇到问题？**您希望能够测试各种各样的东西，比如那些组件无论其上下文如何都可以工作，并且所有Javascript逻辑都按预期工作。当元素具有单个假设的上下文或者分别将一大堆逻辑嵌入到单个函数中时，这可能很难。如果测试具有大量标记和样式的单个巨型组件，渲染测试也会变得难以处理。
6. **你有明确的理由吗？**在分割代码时，您应该考虑它究竟实现了什么。这是否允许更松散的耦合？我是否打破了一个逻辑上有意义的独立实体？这个代码是否真的可能在其他地方重复使用？如果你不能清楚地回答这个问题，那么你只是为了它而将代码分成（可能紧密耦合的）块，这可能会导致问题。
7. **这些好处是否超过了成本？**分离代码不可避免地需要时间和精力，其数量根据具体情况而变化，并且在最终做出此决定时会有许多因素（例如此列表中的点等等）。一般来说，对抽象的成本和收益进行一些研究可以帮助您了解在为代码做出此决定时要记住的一些因素。最后，我提到了这一点，因为如果我们过分关注优势，就很容易忘记所需的努力。权衡一切并做出明智的决定。

### 集中/共享的州住宿

许多大型应用程序使用Redux或Vuex等集中存储工具（或者具有React的Context API等状态共享设置）。这意味着他们从商店获得道具而不是通过父母传递。在考虑组件的可重用性时，您不仅要考虑直接的，父母的道具，还要考虑商店的道具。如果您在另一个项目中使用该组件，则需要在商店中使用这些值。或许其他项目根本不使用集中存储工具，您必须将其转换为现在作为父级道具传递的形式。

由于将组件挂接到商店（或上下文提供程序）很容易并且无论组件的层次结构位置如何都可以完成，因此很容易在商店和整个层次结构中的组件Web之间快速创建大量紧密耦合。通常将组件连接到商店只需几行，然后它为您附加的每个属性/功能添加一条额外的行。请记住，虽然这种耦合可能很容易，但它的含义并没有什么不同，你应该想办法减轻风险，就像你使用父母道具一样。

### 最后的想法

我想简要提醒一下这些原则的实际应用，或者您可能阅读的任何最佳实践。虽然你应该尽力维护良好的设计，不要为了包装JIRA票或关闭拉动请求而损害代码完整性，同时总是把理论置于现实世界结果之上的人也往往会让他们的工作受到影响。大型软件项目有许多活动部分，软件工程的许多方面与编码没有特别的关系，但仍然是不可或缺的，例如遵守最后期限和处理非技术期望。

虽然充分的准备很重要，应该成为任何专业软件设计的一部分，但在现实世界中，切实的结果是至关重要的。当你被雇用来实际创造一些东西时，如果在最后期限到来之前，你有一个如何完美地构建产品的惊人**计划**，没有实际的开发，你的雇主就不会太高兴。此外，软件工程中的东西很少完全按计划进行，因此过度具体的计划往往会在时间使用方面开始适得其反。

此外，组件规划和设计的概念也适用于组件重构。虽然用了50年的时间来计划一切令人难以忍受的细节，然后从一开始就完美地编写它就会很好，回到现实世界，当你的关键时刻到来时你可能会发现自己设计组件并以不太理想的方式编写代码。然而，一旦压力得到缓解并且你有时间，那么返回并重构早期没有理想构建的代码总是一个好主意，这样它就可以作为向前发展的坚实基础。

在一天结束时，虽然你的直接责任可能是“编写代码”，但你不应忽视你的最终目标，即建立一些东西。创建产品。为了产生一些你可以引以为豪的东西并帮助人们，即使它在技术上并不完美。因为什么都没有。永远记得找到一个平衡点。不幸的是，在一周内每天8小时盯着代码库不幸地催生了一个狭窄的，近视的项目视图，但是你需要在需要的时候退后一步，确保你不要错过森林对于树木。